import React from 'react';
import PropTypes from 'prop-types';
import { Editor, Node, Block, Data, Mark, Inline, Text, Raw, Html, Plain } from 'slate';
import { Select, Tooltip } from 'antd';
import './AntdEditor.less';
import "font-awesome/css/font-awesome.min.css";
import classNames from 'classnames';
import { TwitterPicker } from "react-color";
import InsertLinkModal from "./components/InsertLinkModal";
import InsertImageModal from "./components/InsertImageModal";
class AntdEditor extends React.Component {
  constructor(props) {
    super(props);
    this.initialized = false;
    function parseCSS(css) {
      String.prototype.transform = function () {
        let re = /-(\w)/g;
        return this.replace(re, function () {
          let args = arguments;
          return args[1].toUpperCase();
        })
      };
      String.prototype.trim = function () {
        return this.replace(/(^\s*)|(\s*$)/g, "");
      };
      let result = {};
      const styles = css.split(';');
      styles.forEach(style => {
        let a = style.split(':');
        if (a.length === 2) {
          a[0] = a[0].trim();
          a[1] = a[1].trim();
          a[0] = a[0].transform();
          result[a[0]] = a[1];
        }
      });
      return result;
    }

    this.serializer = new Html({
      rules: [
        {
          deserialize(el, next){
            if (el.type === 'tag') {
              let data = parseCSS(el.attribs.style || '');
              switch (el.name) {
                case 'video':
                  return {
                    kind: 'inline',
                    type: 'video',
                    data: {
                      src: el.attribs.src,
                      width: el.attribs.width,
                      height: el.attribs.height,
                      autoPlay: el.attribs.autoplay,
                      controls: el.attribs.controls,
                    },
                    isVoid: true
                  };
                case 'img':
                  return {
                    kind: 'inline',
                    type: 'image',
                    data: {
                      src: el.attribs.src,
                      width: el.attribs.width,
                      height: el.attribs.height,
                      alt: el.attribs.alt,
                    },
                    isVoid: true
                  };
                case 'span':
                  return {
                    kind: 'inline',
                    type: 'span',
                    data: { ...data },
                    nodes: next(el.children)
                  };
                case 'div':
                case 'p':
                  return {
                    kind: 'block',
                    type: 'line',
                    data: { ...data },
                    nodes: next(el.children)
                  };
                case 'strong':
                  return {
                    kind: 'mark',
                    type: 'bold',
                    nodes: next(el.children)
                  }
              }
            }
          },
          serialize(el, next){
            if (el.kind === 'mark') {
              switch (el.type) {
                case 'bold':
                  return <b>{next}</b>;
                case 'color':
                  return <span style={{ color: el.data.get('color') }}>{next}</span>;
                case 'fontSize':
                  return <span style={{ fontSize: el.data.get('fontSize') }}>{next}</span>;
              }
            }
            if (el.kind === 'inline') {
              switch (el.type) {
                case 'link':
                  return <a href={el.data.get('href')} target={el.data.get('target')}>{next}</a>;
                case 'image':
                  return <img src={el.data.get('src')} alt={el.data.get('alt')} width={el.data.get('width')}
                              height={el.data.get('height')}/>;
                case 'video':
                  return <video src={el.data.get('src')} autoPlay={el.data.get('autoPlay')} width={el.data.get('width')}
                                height={el.data.get('height')} controls={el.data.get('controls')}/>;
                case 'span':
                  return <span style={{ fontSize: el.data.get('fontSize'), color: el.data.get('color') }}>{next}</span>;
              }
            }
            if (el.kind === 'block') {
              switch (el.type) {
                case 'paragraph':
                  return <p style={{ textAlign: el.data.get('textAlign') }}>{next}</p>;
                case 'line':
                  return <p style={{ textAlign: el.data.get('textAlign') }}>{next}</p>;
              }
            }
          }
        }
      ]
    });
    this.state = {
      state: Plain.deserialize(''),
      fontColorPickerVisible: false,
      backgroundColorPickerVisible: false,
      insertLinkModalVisible: false,
      insertImageModalVisible: false,
      insertAudioModalVisible: false,
      insertVideoModalVisible: false,
    };
  }

  fontSizes = [12, 14, 16, 18, 20, 22, 24, 28, 32];
  headings = {
    'h1': { title: '一级标题', label: <h1>一级标题</h1> },
    'h2': { title: '二级标题', label: <h2>二级标题</h2> },
    'h3': { title: '三级标题', label: <h3>三级标题</h3> },
    'h4': { title: '四级标题', label: <h4>四级标题</h4> },
    'p': { title: '正文', label: <p>正文</p> }
  };

  componentWillUnmount() {
    this.initialized = false;
  }

  componentWillReceiveProps(newProps) {
    if (!this.initialized && newProps.value) {
      this.initialized = true;
      this.setState({
        state: this.serializer.deserialize(newProps.value)
      })
    }
  }

  render() {
    return (
      <div className="editor_container">
        {this.renderToolbar()}
        {this.renderEditor()}
      </div>
    )
  }

  renderToolbar() {
    return <div className="toolbar">
      {this.renderHeadingSelect()}
      {this.renderFontSizeSelect()}
      {this.renderMarkButton('bold', <span className="fa fa-bold"/>, '粗体')}
      {this.renderMarkButton('italic', <span className="fa fa-italic"/>, '斜体')}
      {this.renderMarkButton('underline', <span className="fa fa-underline"/>, '下划线')}
      {this.renderMarkButton('strikethrough', <span className="fa fa-strikethrough"/>, '删除线')}
      {this.renderFontColorPicker()}
      {this.renderBackgroundColorPicker()}
      {this.renderAlignmentButton('left', <span className="fa fa-align-left"/>, '居左对齐')}
      {this.renderAlignmentButton('center', <span className="fa fa-align-center"/>, '居中对齐')}
      {this.renderAlignmentButton('right', <span className="fa fa-align-right"/>, '居右对齐')}
      {this.renderAlignmentButton('justify', <span className="fa fa-align-justify"/>, '两端对齐')}
      {this.renderInsertLinkButton()}
      {this.renderInsertAudioButton()}
      {this.renderInsertImageButton()}
      {this.renderInsertVideoButton()}
    </div>
  }

  renderEditor() {
    return <Editor
      className="editor"
      state={this.state.state}
      schema={{
        marks: {
          bold: {
            fontWeight: 'bold'
          },
          italic: {
            fontStyle: 'italic'
          },
          underline: {
            textDecoration: 'underline'
          },
          strikethrough: {
            textDecoration: 'line-through'
          },
          color: props => {
            return <span {...props.attributes} style={{ color: props.mark.data.get('color') }}>{props.children}</span>
          },
          backgroundColor: props => {
            return <span {...props.attributes}
                         style={{ backgroundColor: props.mark.data.get('backgroundColor') }}>{props.children}</span>
          },
          fontSize: props => {
            return <span {...props.attributes}
                         style={{ fontSize: props.mark.data.get('fontSize') }}>{props.children}</span>;
          }
        },
        nodes: {
          link: props => {
            const { data } = props.node;
            return <a {...props.attributes} href={data.get('href')} target={data.get('target')}>{props.children}</a>;
          },
          video: props => {
            const { data } = props.node;
            return <video src={data.get('src')} controls={data.get('controls')} autoPlay={data.get('autoPlay')}
                          width={data.get('width')}
                          height={data.get('height')}/>;
          },
          image: props => {
            const { data } = props.node;
            return <Tooltip
              {...props.attributes}
              title={<div>
                <a
                  style={{ color: '#fff', marginRight: 8 }}
                  onClick={() => {
                    this.setState({
                      currentImage: {
                        src: data.get('src'),
                        alt: data.get('alt'),
                        width: data.get('width'),
                        height: data.get('height'),
                        key: props.node.key
                      },
                      insertImageModalVisible: true
                    });
                  }}
                >修改</a>
                <a
                  style={{ color: '#fff' }}
                  onClick={() => {
                    let { state } = this.state;
                    state = state.transform().removeNodeByKey(props.node.key).apply();
                    this.setState({ state });
                  }}
                >删除</a>
              </div>}>
              <img
                src={data.get('src')} alt={data.get('alt')}
                width={data.get('width')}
                height={data.get('height')}/></Tooltip>;
          },
          line: props => {
            const { data } = props.node;
            return <p {...props.attributes}
                      style={{ textAlign: data.get('textAlign'), fontSize: data.get('fontSize') }}>{props.children}</p>
          },
          header: props => {
            const BlockType = props.node.data.get('blockType');
            const { data } = props.node;
            return <BlockType {...props.attributes}
                              style={{ textAlign: data.get('textAlign') }}>{props.children}</BlockType>
          },
          span: props => {
            const { data } = props.node;
            return <span {...props.attributes} style={{ fontSize: data.get('fontSize') }}>{props.children}</span>
          },
        },
      }}
      onChange={(state) => {
        this.setState({ state });
        setTimeout(() => {
          const html = this.serializer.serialize(this.state.state);
          console.log(html);
          this.props.onChange(html);
        }, 0);
      }}
    />
  }

  renderAlignmentButton(type, label, tooltip) {
    const isActive = this.isAlignment(type);
    return (
      <Tooltip title={tooltip}>
    <span
      className={classNames(
        "toolbar_button",
        { ["toolbar_button:active"]: isActive }
      )}
      onClick={() => {
        this.onClickAlignment(type);
      }}
    >{label}</span>
      </Tooltip>
    )
  }

  renderMarkButton(type, label, tooltip) {
    const isActive = this.hasMark(type);
    return (
      <Tooltip title={tooltip}>
    <span
      className={classNames(
        "toolbar_button",
        { ["toolbar_button_active"]: isActive }
      )}
      onClick={() => {
        this.onClickMark(type);
      }}
    >{label}</span>
      </Tooltip>
    )
  }

  onClickMark(type) {
    let { state } = this.state;
    state = state.transform().toggleMark(type).apply();
    this.setState({ state });
  }

  onClickAlignment(textAlign) {
    let { state } = this.state;
    state = state.transform().setBlock({
      type: state.blocks.first().type,
      data: state.blocks.first().data.merge({ textAlign })
    }).apply();
    this.setState({ state });
  }

  hasBlock(type) {
    const { state } = this.state;
    return state.blocks.some(block => block.type === type);
  }

  hasMark(type) {
    const { state } = this.state;
    return state.marks.some(mark => mark.type === type);
  }

  renderFontSizeSelect() {
    let selectedFontSize = this.getCurrentFontSize() || '12';
    return <div className="select">
      <Select
        placeholder="字体大小"
        value={selectedFontSize}
        onChange={(value) => {
          let { state } = this.state;
          state = state.transform().removeMark('fontSize').addMark(Mark.create({
            type: 'fontSize',
            data: { fontSize: parseInt(value) }
          })).apply();
          this.setState({ state });
        }}>
        {this.fontSizes.map(fontSize => <Select.Option key={fontSize.toString()}
                                                       value={fontSize.toString()}>{fontSize.toString()}</Select.Option>)}
      </Select>
    </div>
  }

  renderHeadingSelect() {
    let selectedHeading = this.getCurrentHeader() || 'p';
    return (
      <div className="select" style={{ width: 130 }}>
        <Select
          value={selectedHeading}
          optionLabelProp="title"
          onChange={(blockType) => {
            let { state } = this.state;
            state = state.transform().setBlock({
              type: 'header',
              data: state.blocks.first().data.merge({ blockType })
            }).apply();
            this.setState({ state });
          }}
        >
          {Object.keys(this.headings).map(heading => {
            return <Select.Option key={heading} value={heading}
                                  title={this.headings[heading].title}>{this.headings[heading].label}</Select.Option>;
          })}
        </Select>
      </div>
    )
  }

  getCurrentHeader() {
    const { state } = this.state;
    if (state.blocks.first().type === 'header') {
      return state.blocks.first().data.get('blockType');
    }
  }

  isAlignment(type) {
    return this.state.state.blocks.first().data.get('textAlign') === type;
  }

  isLink() {
    const { state } = this.state;
    return state.inlines.some(inline => inline.type === 'link');
  }

  getCurrentFontColor() {
    const { state } = this.state;
    if (state.marks.first() && state.marks.first().type === 'color') {
      return state.marks.first().data.get('color');
    }
  }

  getCurrentFontSize() {
    const { state } = this.state;
    if (state.marks.first() && state.marks.first().type === 'fontSize') {
      return state.marks.first().data.get('fontSize').toString();
    }
  }

  renderFontColorPicker() {
    let currentFontColor = this.getCurrentFontColor();
    return (
      <Tooltip title="文字颜色">
        <div
          className="toolbar_button" style={{ position: 'relative' }}
        >
    <span className="fa fa-font" style={{ color: currentFontColor }}
          onClick={() => this.setState({
            fontColorPickerVisible: !this.state.fontColorPickerVisible,
            backgroundColorPickerVisible: false
          })}/>
          <div
            style={{
              display: this.state.fontColorPickerVisible ? 'block' : 'none',
              position: 'absolute',
              zIndex: 9999,
              left: -6
            }}
            onMouseLeave={() => this.setState({ fontColorPickerVisible: false })}
          >
            <TwitterPicker
              onChangeComplete={color => {
                let { state } = this.state;
                state = state.transform().removeMark('color').addMark({
                  type: 'color',
                  data: { color: color.hex }
                }).apply();
                this.setState({ state });
              }}
            />
          </div>
        </div>
      </Tooltip>
    )
  }

  renderBackgroundColorPicker() {
    return (
      <Tooltip title="背景颜色">
        <div
          className="toolbar_button" style={{ position: 'relative' }}
        >
    <span className="fa fa-square" onClick={() => this.setState({
      backgroundColorPickerVisible: !this.state.backgroundColorPickerVisible,
      fontColorPickerVisible: false
    })}/>
          <div
            onMouseLeave={() => this.setState({ backgroundColorPickerVisible: false })}
            style={{
              display: this.state.backgroundColorPickerVisible ? 'block' : 'none',
              position: 'absolute',
              zIndex: 9999,
              left: -6
            }}
          >
            <TwitterPicker
              onChangeComplete={color => {
                let { state } = this.state;
                state = state.transform().removeMark('backgroundColor').addMark({
                  type: 'backgroundColor',
                  data: { backgroundColor: color.hex }
                }).apply();
                this.setState({ state });
              }}
            />
          </div>
        </div>
      </Tooltip>
    )
  }

  renderInsertImageButton() {
    return (
      <Tooltip title="插入图片">
        <div className="toolbar_button"
             onClick={() => this.setState({ currentImage: null, insertImageModalVisible: true })}>
          <span className="fa fa-picture-o"/>
          <InsertImageModal
            visible={this.state.insertImageModalVisible}
            onUpload={this.props.onUploadImage}
            onCancel={() => this.setState({ insertImageModalVisible: false })}
            currentImage={this.state.currentImage}
            onConfirm={(values) => {
              let { state } = this.state;
              if (values.key) {
                state = state.transform().setNodeByKey(values.key, {
                  type: 'image',
                  data: values,
                  isVoid: true
                }).apply();
              } else {
                state = state.transform().insertInline({ type: 'image', data: values, isVoid: true }).apply();
              }
              this.setState({ state, insertImageModalVisible: false });
            }}
          />
        </div>
      </Tooltip>
    )
  }

  renderInsertLinkButton() {
    const isLink = this.isLink();
    return (
      <Tooltip title={isLink ? '取消链接' : '插入链接'}>
        <div className={classNames("toolbar_button", { ["toolbar_button_active"]: isLink })} onClick={() => {
          let { state } = this.state;
          if (isLink) {
            state = state.transform().unwrapInline('link').apply();
            this.setState({ state });
          } else {
            this.setState({ insertLinkModalVisible: true, insertLinkEdit: state.selection.isExpanded });
          }
        }}>
          {isLink ? <span className="fa fa-unlink"/> : <span className="fa fa-link"/>}
          <InsertLinkModal
            visible={this.state.insertLinkModalVisible}
            edit={this.state.insertLinkEdit}
            onCancel={() => this.setState({ insertLinkModalVisible: false })}
            onConfirm={(values) => {
              let { state } = this.state;
              if (state.selection.isExpanded) {
                state = state.transform().unwrapInline('link').wrapInline({
                  type: 'link',
                  data: values
                }).apply();
              } else {
                let { text } = values;
                state = state.transform().insertText(text).extend(0 - text.length).wrapInline({
                  type: 'link',
                  data: values
                }).apply();
              }
              this.setState({ state, insertLinkModalVisible: false });
            }}/>
        </div>
      </Tooltip>
    )
  }

  renderInsertVideoButton() {
    return (
      <Tooltip title="插入视频">
        <div className="toolbar_button">
          <span className='fa fa-video-camera'/>
        </div>
      </Tooltip>
    )
  }

  renderInsertAudioButton() {
    return (
      <Tooltip title="插入音频">
        <div className="toolbar_button">
          <span className="fa fa-music"/>
        </div>
      </Tooltip>
    )
  }

}
AntdEditor.propTypes = {
  onUploadImage: PropTypes.func
};
export default AntdEditor;